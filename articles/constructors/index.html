<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Invocation Patterns: Constructors - Backdeskwinter
    </title>
    <link rel="alternate" href="http://localhost:7777/feed.xml" type="application/rss+xml" title="Digital content done right">
    <link rel="stylesheet" id="foundation_google_fonts-css" href="//fonts.googleapis.com/css?family=Lato%3A300%2C600%7CRoboto%3A400%2C700%2C400italic%2C700italic&amp;amp;ver=2.2" type="text/css" media="">
    <link rel="stylesheet" href="/css/main.css">
  </head>
  <body class="article-detail">
    <header class="header">
      <div class="content-wrap">
        <h1>Invocation Patterns: Constructors</h1>
        <p class="author">Written by <span class="author">James Gardner</span>
        </p>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article">
          <section class="content"><p>In his book ‘JavaScript: The good parts’, Douglas Crockford covers ‘invocation’ in some detail listing the four&nbsp;patterns:</p>
<p>1 Method 
2 Function
3 Constructor
4&nbsp;Apply</p>
<p>It wasn’t until I read this chapter that I really got to grips with JavaScript. Since functions are ‘first class’ objects in JavaScript a lot naturally rests on how they are&nbsp;invoked. </p>
<blockquote>
<p>If the function was invoked with the new prefix and the return value is not an object, then this (the new object) is returned instead. 
<cite>D.Crockford - JavaScript: The Good Parts</cite></p>
</blockquote>
<p>I see this pattern used quite often in projects I am involved in and I am keen to understand the benefits of it and the problem(s) it&nbsp;addresses.</p>
<pre><code>var MyConstructor = require(&#39;myConstructor&#39;);

createObject = function (configuration) {
    return new MyConstructor(configuration);
};

module.exports = {
    create : createObject
};
</code></pre><p>In my mind there’s redundancy in this example because all this is really does is stop me from using constructor invocation directly. In short it means I don’t have to use the ‘new’&nbsp;keyword.</p>
<pre><code>var myConstructedItem = createObject(configuration);
</code></pre><p>I think the intention here is to provide a factory-style api and I’d be an advocate of that if it hid away any kind of decision making like you might see in the example of the <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/#factorypatternjavascript">factory pattern</a>.</p>
<pre><code>createObject = function (type, configuration) {
    var ObjClass;

    switch(type) {
        case &#39;x&#39; : ObjClass = new SomeConstructor;
                   break;

        default  : ObjClass = new OtherConstructor;
                   break;
    }

    return new ObjClass(configuration);
};

module.exports = {
    create : createObject
};
</code></pre><p>Clearly in the first example there isn’t any of that. It just returns a wrapper around a&nbsp;constructor. </p>
<p>It’s worth noting that exported objects in CommonJS are ‘cached’ and that you’ll always get the same object/value every time you require in the module. So if you export a constructor, you’ll naturally get the same constructor each&nbsp;time.</p>
<p>In my mind constructor functions are a factory in their own&nbsp;right:</p>
<blockquote>
<p>If the function was invoked with the new prefix and the return value is not an object, then this (the new object) is returned instead. 
<cite>D.Crockford - JavaScript: The Good Parts</cite></p>
</blockquote>
</section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="/">« Full blog</a></div>
        <section class="about"><small><p>Backdesk Solutions Ltd is a limited company registered in England and
Wales. Company registration No. 09224652. VAT Registration No. 200147179.</p>
</small></section>
        <section class="copy"><small>&copy; 2014 Backdesk Solutions Ltd</small></section>
      </div>
    </footer>
  </body>
</html>